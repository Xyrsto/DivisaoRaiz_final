.DATA
;----------VARIAVEIS DA INTERFACE----------
MSGINTERFACE0 DB '                            |------------------| $'  
MSGINTERFACE1 DB '                            |-----WELCOME!-----| $'
MSGINTERFACE2 DB '                            |------------------| $'
MSGCHOICE DB 'ESCOLHA QUE ALGORITMO PRETENDE EXECUTAR[1- DIVISAO, 2- RAIZ QUADRADA]:  $'
CHOICE DW 0

;----------VARIAVEIS DA DIVISAO----------
DIVIDENDO DW 10 DUP(10)
HIGHORDER DW 0 
DIVISOR DW 0 
IMULT DW 0 
RESTO DW 0 
QUOCIENTE DW 0  
ARRAYPOS DW -2 
ARRAYPOSINPUT DW -2  
CALCQUOCIENTERESTO DW 0  
MSGDIVIDENDO DB 'QUANTOS DIGITOS PRETENDE USAR NO DIVIDENDO: $'
MSGDIVISOR DB 'QUANTOS DIGITOS PRETENDE USAR NO DIVISOR: $' 
MSGNEGATIVO DB 'PRETENDE QUE O NUMERO SEJA NEGATIVO? SE SIM, PRESSIONE - : $'
MSGDIGITO DB 'INSIRA UM DIGITO: $' 
MSGRESULTADO DB 'QUOCIENTE: $'  
MSGRESTO DB 'RESTO: $'
NDIGITOSDIVID DW 0
NDIGITOSDIVISOR DW 0
INPUTDIGITDIVISOR DW 0 
ARRAYRESULTDIVISAO DW 6 DUP(0) 
QCOUNT DW -2 
NEGATIVO DW 0

;----------VARIAVEIS DA RAIZ QUADRADA----------
MESSAGERADICANDO DB 'INSIRA O NUMERO DE DIGITOS QUE PRETENDE USAR PRA O RADICANDO: $' 
MSGRESULTADORAIZ DB 'RESULTADO: $'   
HIGHORDER1 DW 0  
HIGHORDER2 DW 0
I  DW -1
J  DW -1
NALGARISMO DW 0
NDIGITSHIGHORDER DW -1   
RADICANDO DW 10 DUP(10) 
ARRAYPOSATUAL DW -2
RESULTFINAL DW 0 
AUX DW 0  
NDIGITOSRADICANDO DW 0  
ARRAYRESULTRAIZ DW 6 DUP(0)

.CODE
;MENSAGEM DE BOAS VINDAS
WELCOMEPROC PROC
    MOV DX, OFFSET MSGINTERFACE0
    MOV AH, 09H
    INT 21H     
    CALL CH_NEXTLINE 
    
    MOV DX, OFFSET MSGINTERFACE1
    MOV AH, 09H
    INT 21H     
    CALL CH_NEXTLINE
    
    MOV DX, OFFSET MSGINTERFACE2
    MOV AH, 09H
    INT 21H     
    CALL CH_NEXTLINE
    
    RET
ENDP
  
CH_NEXTLINE PROC
    ;ESCREVE NA LINHA A SEGUIR 
    MOV DL, 0AH
    MOV AH, 02H
    INT 21H 
    MOV DL, 0DH
    MOV AH, 02H
    INT 21H 
    RET
ENDP

;VERIFICA SE O INPUT É VÁLIDO
CHECK_NDIGITOSDIVID PROC
    CMP AX, 0
    JLE GET_DIGITOSDIVIDENDO
    
    CMP AX,9
    JG GET_DIGITOSDIVIDENDO
    
    RET
ENDP

;RECEBE - SE O NUMERO EM QUESTAO FOR NEGATIVO
N_NEGATIVO PROC
    CALL CH_NEXTLINE
    MOV DX, OFFSET MSGNEGATIVO
    MOV AH, 09H
    INT 21H
    
    MOV AH, 01H
    INT 21H
    
    CMP AL, 2DH
    JNE NEGATIVOCONTINUE
    
    ADD NEGATIVO, 1 
    
    NEGATIVOCONTINUE:      
    RET
ENDP


;RECEBE O NUMERO DE DIGITOS DO DIVIDENDO
GET_DIGITOSDIVIDENDO PROC
    CALL CH_NEXTLINE
    
    MOV DX, OFFSET MSGDIVIDENDO
    MOV AH, 09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    
    SUB AX, 130H
    
    ;VERIFICA SE O INPUT É VÁLIDO
    CALL CHECK_NDIGITOSDIVID
    
    MOV NDIGITOSDIVID, AX    
    RET
ENDP

;RECEBE DIGITO A DIGITO E GUARDA NO ARRAY DIVIDENDO
GET_DIVIDENDO PROC
    DEC NDIGITOSDIVID
    CALL CH_NEXTLINE
    
    NOTVALIDJUMPDIVIDENDO:    
    MOV DX, OFFSET MSGDIGITO
    MOV AH, 09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    SUB AX, 130H
    
    ;VERIFICA SE O INPUT É VÁLIDO
    CMP AX, 0
    JL NOTVALIDJUMPDIVIDENDO
    
    CMP AX,9
    JG NOTVALIDJUMPDIVIDENDO 
    
    ADD ARRAYPOSINPUT,2
    MOV BX, ARRAYPOSINPUT
    MOV DIVIDENDO[BX], AX
    ;MOV LASTINSERTED, AX
    
    CMP NDIGITOSDIVID, 0
    JNE GET_DIVIDENDO
         
    RET
ENDP

;VERIFICA SE O INPUT É VÁLIDO
CHECK_NDIGITOSDIVISOR PROC
    CMP AX, 0
    JLE GET_NDIGITOSDIVISOR
    
    CMP AX,9
    JG GET_NDIGITOSDIVISOR
    
    RET
ENDP  

;RECEBE O NUMERO DE DIGITOS DO DIVISOR
GET_NDIGITOSDIVISOR PROC
    MOV DIVISOR, 0
    CALL CH_NEXTLINE
    
    MOV DX, OFFSET MSGDIVISOR
    MOV AH, 09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    
    SUB AX, 130H
    
    ;VERIFICA SE O INPUT É VÁLIDO
    CALL CHECK_NDIGITOSDIVISOR
    
    MOV NDIGITOSDIVISOR, AX    
    RET
ENDP

;RECEBE O DIVISOR DIGITO A DIGITO
GET_DIVISOR PROC
    DEC NDIGITOSDIVISOR 
    
    CALL CH_NEXTLINE
    
    NOTVALIDJUMPDIVISOR:
    CALL CH_NEXTLINE    
    MOV DX, OFFSET MSGDIGITO
    MOV AH, 09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    SUB AX, 130H
    
    ;VERIFICA SE O INPUT É VÁLIDO
    CMP AX, 0
    JL NOTVALIDJUMPDIVISOR
    
    CMP AX,9
    JG NOTVALIDJUMPDIVISOR
    
    MOV INPUTDIGITDIVISOR,AX
    
    MOV AX, DIVISOR
    MOV BX, 10
    MUL BX
    ADD AX, INPUTDIGITDIVISOR  
    
    MOV DIVISOR, AX 

    CMP NDIGITOSDIVISOR, 0
    JNE GET_DIVISOR
        
    RET
ENDP

;ALGORITMO DA DIVISAO
DIVISAO PROC 
    INICIO:     
    ;OBTÉM O PRIMEIRO HIGH ORDER DO DIVIDENDO   
    GETHIGHORDER:
        ADD ARRAYPOS, 2 
        MOV BX, ARRAYPOS 
        MOV AX, DIVIDENDO[BX] 
        CMP AX, 10
        JB COMPARAHIGHORDER
        JAE OVERFLOW
    
    ;COMPARA O HIGH ORDER COM O DIVISOR. SE O HIGH ORDER FOR MENOR DO QUE DIVISOR, PASSA PARA A LABEL "CONCATHIGHORDER". SE FOR MAIOR OU IGUAL PASSA PARA A LABEL "FLAG"    
    COMPARAHIGHORDER:
        MOV HIGHORDER, AX
        MOV RESTO, AX
        CMP AX, DIVISOR
        JB CONCATHIGHORDER 
        JAE FLAG          
    
    ;CONCATENA O HIGH ORDER SEGUINTE, CASO O DIVISOR SEJA MAIOR DO QUE O HIGH ORDER INICIAL    
    CONCATHIGHORDER:
        
        ;CERTIFICA-SE DE QUE A POSIÇÃO NO ARRAY A SEGUIR À ATUAL NÃO É 10, SENDO QUE 10 DETERMINA O FIM DO ARRAY
        ADD ARRAYPOS, 2
        MOV BX, ARRAYPOS
        MOV CX, DIVIDENDO[BX]
        CMP CX, 10     
        ;SE A POSICAO A SEGUIR FOR 10, PASSA PARA A LABEL "FLAG", SENÃO PASSA PARA A LABEL "NEXT" 
        JNE NEXT
        JE FLAG
        
        NEXT:    
        MOV CX, 10
        MOV DX, 0 
        MUL CX
        MOV CX, DIVIDENDO[BX]
        ADD AX, CX         
        MOV HIGHORDER, AX
        MOV RESTO, AX 
    
    FLAG:
    ;INICIALIZA IMULT A -1 PARA NÃO SER FEITA 1 ITERAÇÃO A MAIS DENTRO DE "QUOCIENTECALC"                        
    MOV IMULT, -1 
    
    ;ITERA ATÉ ENCONTRAR UM VALOR PARA IMULT MAIOR DO QUE O RESTO. SE IMULT FOR IGUAL AO RESTO, PASSA PARA A LABEL "CALCOPERRESTO". QUANDO IMULT FOR MAIOR DO QUE O RESTO, SALTA PARA A LABEL "ITERANTERIOR"
    QUOCIENTECAL:
        INC IMULT
        MOV CX, IMULT
        MOV AX, DIVISOR
        MOV DX, 0
        MUL CX 
        CMP AX, RESTO
        JB QUOCIENTECAL
        JE CALCOPERRESTO 
    
    ;ITERA O VALOR DE IMULT ANTERIOR QUE RESPEITE A CONDIÇÃO IMULT * DIVISOR < RESTO     
    ITERANTERIOR:
        DEC IMULT 
    
    ;CALCULA O VALOR QUE VAI SER SUBTRAIDO PELO RESTO 
    CALCOPERRESTO:
        MOV AX, IMULT
        MUL DIVISOR
        MOV BX, RESTO
        MOV CALCQUOCIENTERESTO, AX
    
    ;EFETUA A OPERAÇÃO RESTO - CALCQUOCIENTERESTO    
    OPERACAORESTO:
        MOV AX, RESTO
        SUB AX, CALCQUOCIENTERESTO
        MOV RESTO, AX
    
    ;ESTRUTURA DE CONTROLO DO QUOCIENTE   
    CALCQUOCIENTE2:
        ;CERTIFICA-SE DE QUE A POSIÇÃO NO ARRAY A SEGUIR À ATUAL NÃO É 10, SENDO QUE 10 DETERMINA O FIM DO ARRAY
        MOV BX, ARRAYPOS
        ADD BX,2
        CMP DIVIDENDO[BX], 10
        ;SE A POSICAO A SEGUIR FOR 10, PASSA PARA A LABEL "CONCATQUOCIENTE", SENÃO PASSA PARA A LABEL "FLAG2" 
        JNE FLAG2
        JE  CONCATQUOCIENTE
            
        FLAG2:
        MOV DX, 0 
        MOV AX, RESTO
        MOV BX, 10
        MUL BX
        MOV RESTO, AX
        
        ;CERTIFICA-SE DE QUE A POSIÇÃO NO ARRAY A SEGUIR À ATUAL NÃO É 10, SENDO QUE 10 DETERMINA O FIM DO ARRAY 
        MOV BX, ARRAYPOS
        ADD BX,2
        CMP DIVIDENDO[BX], 10
        ;SE A POSICAO A SEGUIR NÃO FOR 10, PASSA PARA A LABEL "CONCATRESTO"
        JNE CONCATRESTO
    
    ;CONCATENA O VALOR CALCULADO ANTERIORMENTE AO RESTO
    CONCATRESTO:
        MOV AX, RESTO 
        ADD AX, DIVIDENDO[BX] 
        MOV RESTO, AX
    
    ;CONCATENA O VALOR CALCULADO ANTERIORMENTE AO QUOCIENTE
    CONCATQUOCIENTE:
        MOV AX, 10
        MUL QUOCIENTE
        ADD AX, IMULT
        MOV QUOCIENTE, AX
    
    ;VERIFICA SE A POSICAO ATUAL É A ULTIMA POSICAO DO ARRAY          
    CONDICAOJUMP:
        MOV IMULT, -1
        MOV BX, ARRAYPOS
        ADD BX,2
        ADD ARRAYPOS,2
        CMP DIVIDENDO[BX], 10
        JNE QUOCIENTECAL
        JE  OVERFLOW                        
    OVERFLOW:
        RET
ENDP

;MOSTRA O RESULTADO DA DIVISAO
MOSTRARESULTDIVISAO PROC
    CALL CH_NEXTLINE
    MOV DX, OFFSET MSGRESULTADO
    MOV AH, 09H
    INT 21H
    
    ;SEPARA OS DIGITOS DO QUOCIENTE E GUARDA NUM ARRAY ARRAYRESULTDIVISAO
    SEPARADIGITOS: 
        MOV DX,0
        MOV AX, QUOCIENTE
        MOV BX, 10
        DIV BX
        MOV QUOCIENTE,AX
        ADD QCOUNT, 2
        MOV BX, QCOUNT
        MOV ARRAYRESULTDIVISAO[BX], DX
        CMP QUOCIENTE, 0
        JG SEPARADIGITOS
        
        ;SE FOR NEGATIVO ADICIONA - AO QUOCIENTE
        CMP NEGATIVO,1
        JNE MOSTRAQUOCIENTE0
        
        MOV DL,0F0H
        MOV AH, 06H
        INT 21H 
        
        ;MOSTRA O QUOCIENTE 
        MOSTRAQUOCIENTE0:
        ADD QCOUNT, 2
        MOSTRAQUOCIENTE:
        SUB QCOUNT, 2
        MOV BX, QCOUNT
        MOV AX, ARRAYRESULTDIVISAO[BX]
        MOV DX, AX
        ADD DX, 130H
        MOV AH, 06H
        INT 21H
        CMP QCOUNT, 0
        JNE MOSTRAQUOCIENTE
        
        ;MOSTRA O RESTO
        CALL CH_NEXTLINE
        MOV QCOUNT, -2
        SEPARARESTO:
        MOV DX,0
        MOV AX, RESTO
        MOV BX, 10
        DIV BX
        MOV RESTO,AX
        ADD QCOUNT, 2
        MOV BX, QCOUNT
        MOV ARRAYRESULTDIVISAO[BX], DX
        CMP RESTO, 0
        JG SEPARARESTO
        
        MOV DX, OFFSET MSGRESTO
        MOV AH,09H
        INT 21H
        
        ;MOSTRA O RESTO
        MOSTRARESTO0:
        ADD QCOUNT, 2
        MOSTRARESTO:
        SUB QCOUNT, 2
        MOV BX, QCOUNT
        MOV AX, ARRAYRESULTDIVISAO[BX]
        MOV DX, AX
        ADD DX, 130H
        MOV AH, 06H
        INT 21H
        CMP QCOUNT, 0
        JNE MOSTRARESTO
                
        RET    
ENDP

;RECEBE O NUMERO DE DIGITOS DO RADICANDO
GET_NDIGITOSRADICANDO PROC
    CALL CH_NEXTLINE
    MOV DX, OFFSET MESSAGERADICANDO
    MOV AH, 09H
    INT 21H
    
    MOV AH, 01H
    INT 21H
    SUB AX, 130H 
        
    CMP AX, 0
    JLE GET_NDIGITOSRADICANDO
    
    CMP AX, 9
    JG GET_NDIGITOSRADICANDO
    
    MOV NDIGITOSRADICANDO, AX
        
    RET
ENDP

;RECEBE RADICANDO DIGITO A DIGITO E GUARDA NO ARRAY RADICANDO
GET_RADICANDO PROC 
    CALL CH_NEXTLINE
    DEC NDIGITOSRADICANDO
    CALL CH_NEXTLINE
    
    NOTVALIDJUMPRADICANDO:    
    MOV DX, OFFSET MSGDIGITO
    MOV AH, 09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    SUB AX, 130H
    
    ;VERIFICA SE O INPUT É VÁLIDO
    CMP AX, 0
    JL NOTVALIDJUMPRADICANDO
    
    CMP AX,9
    JG NOTVALIDJUMPRADICANDO
    
    ADD ARRAYPOSINPUT,2
    MOV BX, ARRAYPOSINPUT
    MOV RADICANDO[BX], AX
    
    CMP NDIGITOSRADICANDO, 0
    JNE GET_RADICANDO
         
    RET
ENDP

;ALGORITMO DA RAIZ QUADRADA
SQRTALGORITMO PROC
    NDIGITOS: ;DEVOLVE O NÚMERO DE ALGARISMO DO RADICANDO
       ADD ARRAYPOS, 2 
       INC NALGARISMO 
       MOV BX, ARRAYPOS
       MOV AX, RADICANDO[BX] 
       MOV CX, ARRAYPOS
       ADD CX, 2
       MOV BX, CX
       MOV CX, RADICANDO[BX]
       CMP CX, 10
       JE ISEVEN
       JNE NDIGITOS
    
    ISEVEN: ;VERIFICA SE O NUMERO DE DIGITOS É PAR
        MOV DX,0  
        MOV BX, 2 
        MOV AX, NALGARISMO
        DIV BX  
        CMP DX, 0
        JNE GETHIGHORDERPAIRIFNOTEVEN
        JE  GETHIGHORDERPAIRIFEVEN
        
    GETHIGHORDERPAIRIFNOTEVEN:  ;OBTEM O HIGH ORDER SE NALGARISMO FOR IMPAR   
        ADD ARRAYPOSATUAL, 2
        MOV BX, ARRAYPOSATUAL
        MOV AX, RADICANDO[BX] 
        MOV HIGHORDER1, AX
        DEC NALGARISMO
        JMP ITERACAO1    
     
    GETHIGHORDERPAIRIFEVEN:   ;OBTEM O HIGH ORDER SE NALGARISMO FOR PAR
        ADD ARRAYPOSATUAL, 2
        MOV BX, ARRAYPOSATUAL
        MOV AX, RADICANDO[BX] 
        MOV CX, 10
        MUL CX
        MOV BX, ARRAYPOSATUAL
        ADD BX, 2
        MOV ARRAYPOSATUAL, BX
        MOV CX, RADICANDO[BX]
        ADD AX, CX        
        MOV HIGHORDER1, AX       
      
    ITERACAO1: ;DESCOBRE QUAL O VALOR DE I QUE É MAIOR DO QUE O VALOR DO HIGHORDER1
        INC I
        MOV AX,I
        MUL AX
        CMP AX, HIGHORDER1
        JA DECREMENT 
        JBE ITERACAO1
    
    DECREMENT: ;DECREMENTA I PARA UTILIZARMOS O VALOR CORRETO
        DEC I 
    
    SUBTRACAO:  ;SUBTRAI O HIGHORDER AO VALOR GUARDADO EM AX MULTIPLICADO POR I
        MOV AX, ARRAYPOSATUAL
        ADD AX, 2      
        MOV BX,AX
        CMP RADICANDO[BX], 10
        JE FINALRESULT1
        
        MOV AX, I
        MUL AX
        SUB HIGHORDER1, AX 
    
    GETNEXTHIGHORDERPAIR:   ;OBTEM O HIGH ORDER SE NALGARISMO FOR PAR
        ADD ARRAYPOSATUAL, 2
        MOV BX, ARRAYPOSATUAL
        MOV AX, RADICANDO[BX] 
        MOV CX, 10
        MUL CX
        MOV BX, ARRAYPOSATUAL
        ADD BX, 2
        MOV ARRAYPOSATUAL, BX
        MOV CX, RADICANDO[BX]
        ADD AX, CX        
        MOV HIGHORDER2, AX
        
            
    MOV AX, HIGHORDER2
    GETHIGHORDERNDIGITS: ;OBTEM O NUMERO DE DIGITOS DO HIGHORDER
        MOV DX, 0
        INC NDIGITSHIGHORDER
        MOV BX, 10
        DIV BX
        CMP AX, 0       
        JNE GETHIGHORDERNDIGITS
    
    ELEVADO: ;VERIFICA QUAL É A POTENCIA DE 10 MAIS ADEQUADA PARA O PASSO SEGUINTE
        MOV AX, 10
        MUL AX
        MOV CX, NDIGITSHIGHORDER
        DEC NDIGITSHIGHORDER
        CMP CX, 0
        JNE ELEVADO

    
    CONCATHIGHORDERRAIZ:   ;CONCATENA O PROXIMO HIGHORDER AO HIGHORDER ATUAL
        MOV BX, HIGHORDER1
        MUL BX
        ADD AX, HIGHORDER2 
        MOV HIGHORDER1, AX 
        
    OPER1: ;OPERACAO (2*I*10)
        MOV AX,I
        MOV BX, 2
        MUL BX
        MOV BX, 10
        MUL BX
        MOV AUX, AX
    
    DESCOBREJ:  ;DESCOBRE O J MAIOR DO QUE O NECESSARIO PARA A PROXIMA OPERACAO
        INC J
        MOV BX, J
        MOV AX, AUX
        ADD AX, BX
        MUL BX
        MOV BX, HIGHORDER1
        CMP AX, BX
        JG DECREMENTAJ
        JLE DESCOBREJ
    
    DECREMENTAJ: ;DECREMENTA J PARA O VALOR NECESSARIO
        DEC J
    
    OPER2: ; ADICIONA J À VARIAVEL "AUX" E MULTIPLICA POR J O RESULTADO EM AX.
        MOV AX,AUX
        MOV BX, J
        ADD AX, J
        MUL J
        MOV AUX,AX
        
    SUBTRACAO2:
        MOV AX, HIGHORDER1
        MOV BX, AUX
        SUB AX, BX
        MOV HIGHORDER1, AX
    
    CONCATI: ;CONCATENA O I AO I ANTERIOR
        MOV AX, I
        MOV BX, 10
        MUL BX     
        ADD AX, J
        MOV I, AX
        
        MOV BX, ARRAYPOSATUAL
        ADD BX, 2
        CMP RADICANDO[BX],10        
        JNE GETNEXTHIGHORDERPAIR
        JE FINALRESULT1
    
    FINALRESULT1: ;MOSTRA O RESULTADO FINAL
        MOV RESULTFINAL,0
        MOV AX,I
        MOV RESULTFINAL, AX 
    
    MOV ARRAYPOS,0
    MOV BX, ARRAYPOS
    CMP RADICANDO[BX],0
    JE FINAL   
             
    FINAL:
    RET
ENDP

;MOSTRA RESULTADO DA RAIZ QUADRADA
MOSTRARESULTSQRT PROC
    CALL CH_NEXTLINE
    MOV DX, OFFSET MSGRESULTADORAIZ
    MOV AH, 09H
    INT 21H
    
    ;SEPARA OS DIGITOS DO QUOCIENTE E GUARDA NUM ARRAY ARRAYRESULTDIVISAO
    SEPARADIGITOSRAIZ: 
        MOV DX,0
        MOV AX, RESULTFINAL
        MOV BX, 10
        DIV BX
        MOV RESULTFINAL,AX
        ADD QCOUNT, 2
        MOV BX, QCOUNT
        MOV ARRAYRESULTRAIZ[BX], DX
        CMP RESULTFINAL, 0
        JG SEPARADIGITOSRAIZ
        
        ;MOSTRA O QUOCIENTE 
        MOSTRARAIZ0:
        ADD QCOUNT, 2
        MOSTRARAIZ:
        SUB QCOUNT, 2
        MOV BX, QCOUNT
        MOV AX, ARRAYRESULTRAIZ[BX]
        MOV DX, AX
        ADD DX, 130H
        MOV AH, 06H
        INT 21H
        CMP QCOUNT, 0
        JNE MOSTRARAIZ
    RET
ENDP


MAIN PROC FAR
    MOV DX, @DATA
    MOV DS, DX
    
    ;PROC INICIAL
    CALL WELCOMEPROC
    CALL CH_NEXTLINE
    
    ;ESCOLHA DO ALGORITMO A EXECUTAR
    ESCOLHAALGORITMO:
    MOV DX, OFFSET MSGCHOICE
    MOV AH, 09H
    INT 21H
    
    MOV AH, 01H
    INT 21H
    SUB AX, 130H
    MOV CHOICE, AX
    
    CALL CH_NEXTLINE
    
    ;SE 1: EXECUTA A DIVISAO, SE 2 EXECUTA A RAIZ QUADRADA
    CMP CHOICE, 1
    JE DIVCHOICE
    
    CMP CHOICE, 2
    JE SQRTCHOICE
    JNE ESCOLHAALGORITMO 
    
    
    DIVCHOICE:
    ;RECEBE O NUMERO DE DIGITOS DO DIVIDENDO
    CALL GET_DIGITOSDIVIDENDO
    
    ;RECEBE O CARACTER - CASO O DIVIDENDO SEJA NEGATIVO
    CALL N_NEGATIVO
    
    ;RECEBE O DIVIDENDO DIGITO A DIGITO E GUARDA NO ARRAY DIVIDENDO
    CALL GET_DIVIDENDO
    
    CALL CH_NEXTLINE
    
    ;RECEBE O NUMERO DE DIGITOS DO DIVISOR
    CALL GET_NDIGITOSDIVISOR
    
    ;RECEBE O CARACTER - CASO O DIVISOR SEJA NEGATIVO
    CALL N_NEGATIVO 
    
    ;RECEBE O DIVISOR DIGITO A DIGITO E GUARDA NA VARIAVEL DIVISOR
    CALL GET_DIVISOR
    
    ;EXECUTA O ALGORITMO DA DIVISAO
    CALL DIVISAO
    
    CALL CH_NEXTLINE
    
    ;MOSTRA O QUOCIENTE E O RESTO NO ECRA
    CALL MOSTRARESULTDIVISAO
    
    JMP FIM
    SQRTCHOICE:
    ;;RECEBE O NUMERO DE DIGITOS DO RADICANDO
    CALL GET_NDIGITOSRADICANDO
    
    ;RECEBE O RADICANDO DIGITO A DIGITO E GUARDA NO ARRAY RADICANDO
    CALL GET_RADICANDO
    
    ;EXECUTA O ALGORITMO DA RAIZ QUADRADA
    CALL SQRTALGORITMO
    
    ;MOSTRA RESULTADO DA RAIZ QUADRADA
    CALL MOSTRARESULTSQRT
    
    FIM:
    HLT   
ENDP
END MAIN